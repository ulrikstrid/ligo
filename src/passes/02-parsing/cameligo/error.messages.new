interactive_expr: Begin Fun WILD ARROW Bytes SEMI
##
## Ends in an error in state: 571.
##
## sequence -> Begin option(series) . End [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr C_None CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Begin option(series)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 544, spurious reduction of production seq_expr -> disj_expr_level 
## In state 507, spurious reduction of production last_expr -> seq_expr 
## In state 560, spurious reduction of production fun_expr(last_expr) -> Fun nseq(irrefutable) ARROW last_expr 
## In state 556, spurious reduction of production last_expr -> fun_expr(last_expr) 
## In state 555, spurious reduction of production series -> last_expr 
## In state 570, spurious reduction of production option(series) -> series 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Fun With
##
## Ends in an error in state: 545.
##
## fun_expr(last_expr) -> Fun . nseq(irrefutable) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Verbatim Then Fun With
##
## Ends in an error in state: 522.
##
## fun_expr(closed_if) -> Fun . nseq(irrefutable) ARROW closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Verbatim Then If Verbatim Then Verbatim COMMA Bytes With
##
## Ends in an error in state: 540.
##
## if_then_else(closed_if) -> If expr Then closed_if . Else closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 322, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level 
## In state 321, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA) 
## In state 243, spurious reduction of production tuple_expr -> tuple(disj_expr_level) 
## In state 527, spurious reduction of production base_expr(closed_if) -> tuple_expr 
## In state 406, spurious reduction of production base_if_then_else__open(closed_if) -> base_expr(closed_if) 
## In state 405, spurious reduction of production closed_if -> base_if_then_else__open(closed_if) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Verbatim Then If Verbatim With
##
## Ends in an error in state: 520.
##
## if_then_else(closed_if) -> If expr . Then closed_if Else closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Verbatim Then Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 531.
##
## let_expr(closed_if) -> seq(Attr) Let Rec let_binding . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
## In state 338, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Verbatim Then Let Rec With
##
## Ends in an error in state: 530.
##
## let_expr(closed_if) -> seq(Attr) Let Rec . let_binding In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Verbatim Then Let WILD EQ Bytes With
##
## Ends in an error in state: 538.
##
## let_expr(closed_if) -> seq(Attr) Let let_binding . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
## In state 338, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Verbatim Then Let With
##
## Ends in an error in state: 529.
##
## let_expr(closed_if) -> seq(Attr) Let . let_binding In closed_if [ Else ]
## let_expr(closed_if) -> seq(Attr) Let . Rec let_binding In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Verbatim Then Match Verbatim WILD
##
## Ends in an error in state: 362.
##
## match_expr(base_if_then_else) -> Match expr . With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Verbatim Then Match Verbatim With VBAR Begin
##
## Ends in an error in state: 364.
##
## match_expr(base_if_then_else) -> Match expr With option(VBAR) . cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Verbatim Then Match Verbatim With WILD ARROW Bytes With
##
## Ends in an error in state: 470.
##
## cases(base_cond) -> cases(base_cond) . VBAR case_clause(base_cond) [ VBAR ]
## cases(base_if_then_else) -> cases(base_cond) . VBAR case_clause(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## cases(base_cond)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 454, spurious reduction of production base_expr(base_cond) -> disj_expr_level 
## In state 407, spurious reduction of production base_cond__open(base_cond) -> base_expr(base_cond) 
## In state 408, spurious reduction of production base_cond -> base_cond__open(base_cond) 
## In state 467, spurious reduction of production case_clause(base_cond) -> pattern ARROW base_cond 
## In state 475, spurious reduction of production cases(base_cond) -> case_clause(base_cond) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Verbatim Then Match Verbatim With With
##
## Ends in an error in state: 363.
##
## match_expr(base_if_then_else) -> Match expr With . option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Verbatim Then Module Constr EQ Constr With
##
## Ends in an error in state: 535.
##
## local_module_alias(closed_if) -> module_alias . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 682, spurious reduction of production nsepseq(module_name,DOT) -> Constr 
## In state 685, spurious reduction of production module_alias -> Module Constr EQ nsepseq(module_name,DOT) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Verbatim Then Module Constr EQ Struct Module Constr EQ Constr End With
##
## Ends in an error in state: 533.
##
## local_module_decl(closed_if) -> module_decl . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Verbatim Then Type Ident EQ Constr With
##
## Ends in an error in state: 525.
##
## local_type_decl(closed_if) -> type_decl . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 9, spurious reduction of production variant -> Constr 
## In state 36, spurious reduction of production nsepseq(variant,VBAR) -> variant 
## In state 61, spurious reduction of production sum_type -> nsepseq(variant,VBAR) 
## In state 51, spurious reduction of production type_expr -> sum_type 
## In state 78, spurious reduction of production type_decl -> Type Ident EQ type_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Verbatim Then Verbatim COMMA Bytes With
##
## Ends in an error in state: 542.
##
## if_then_else(seq_expr) -> If expr Then closed_if . Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 322, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level 
## In state 321, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA) 
## In state 243, spurious reduction of production tuple_expr -> tuple(disj_expr_level) 
## In state 527, spurious reduction of production base_expr(closed_if) -> tuple_expr 
## In state 406, spurious reduction of production base_if_then_else__open(closed_if) -> base_expr(closed_if) 
## In state 405, spurious reduction of production closed_if -> base_if_then_else__open(closed_if) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Verbatim Then Verbatim Else With
##
## Ends in an error in state: 543.
##
## if_then_else(seq_expr) -> If expr Then closed_if Else . seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if Else
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Verbatim Then Verbatim With
##
## Ends in an error in state: 537.
##
## base_expr(closed_if) -> disj_expr_level . [ Else ]
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ Or Else COMMA BOOL_OR ]
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level . Or conj_expr_level [ Or Else COMMA BOOL_OR ]
## tuple(disj_expr_level) -> disj_expr_level . COMMA nsepseq(disj_expr_level,COMMA) [ Else ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Verbatim Then With
##
## Ends in an error in state: 528.
##
## let_expr(closed_if) -> seq(Attr) . Let let_binding In closed_if [ Else ]
## let_expr(closed_if) -> seq(Attr) . Let Rec let_binding In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 518, spurious reduction of production seq(Attr) -> 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Verbatim With
##
## Ends in an error in state: 517.
##
## if_then_else(seq_expr) -> If expr . Then closed_if Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 551.
##
## let_in_sequence -> seq(Attr) Let Rec let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
## In state 338, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Let Rec With
##
## Ends in an error in state: 550.
##
## let_in_sequence -> seq(Attr) Let Rec . let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Let WILD EQ Bytes With
##
## Ends in an error in state: 557.
##
## let_in_sequence -> seq(Attr) Let let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
## In state 338, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Let With
##
## Ends in an error in state: 549.
##
## let_in_sequence -> seq(Attr) Let . let_binding In series [ End ]
## let_in_sequence -> seq(Attr) Let . Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Match Verbatim WILD
##
## Ends in an error in state: 343.
##
## match_expr(last_expr) -> Match expr . With option(VBAR) cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Match Verbatim With VBAR Begin
##
## Ends in an error in state: 346.
##
## match_expr(last_expr) -> Match expr With option(VBAR) . cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Match Verbatim With WILD ARROW Bytes VBAR With
##
## Ends in an error in state: 567.
##
## cases(base_cond) -> cases(base_cond) VBAR . case_clause(base_cond) [ VBAR ]
## cases(last_expr) -> cases(base_cond) VBAR . case_clause(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Match Verbatim With WILD ARROW Bytes With
##
## Ends in an error in state: 566.
##
## cases(base_cond) -> cases(base_cond) . VBAR case_clause(base_cond) [ VBAR ]
## cases(last_expr) -> cases(base_cond) . VBAR case_clause(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## cases(base_cond)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 503, spurious reduction of production base_expr(base_cond) -> disj_expr_level 
## In state 407, spurious reduction of production base_cond__open(base_cond) -> base_expr(base_cond) 
## In state 408, spurious reduction of production base_cond -> base_cond__open(base_cond) 
## In state 467, spurious reduction of production case_clause(base_cond) -> pattern ARROW base_cond 
## In state 475, spurious reduction of production cases(base_cond) -> case_clause(base_cond) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Match Verbatim With WILD ARROW Fun With
##
## Ends in an error in state: 504.
##
## fun_expr(base_cond) -> Fun . nseq(irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun . nseq(irrefutable) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Match Verbatim With WILD ARROW If Verbatim With
##
## Ends in an error in state: 359.
##
## if_then(base_cond) -> If expr . Then base_cond [ VBAR ]
## if_then_else(base_cond) -> If expr . Then closed_if Else base_cond [ VBAR ]
## if_then_else(seq_expr) -> If expr . Then closed_if Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 511.
##
## let_expr(base_cond) -> seq(Attr) Let Rec let_binding . In base_cond [ VBAR ]
## let_in_sequence -> seq(Attr) Let Rec let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
## In state 338, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Match Verbatim With WILD ARROW Let Rec With
##
## Ends in an error in state: 510.
##
## let_expr(base_cond) -> seq(Attr) Let Rec . let_binding In base_cond [ VBAR ]
## let_in_sequence -> seq(Attr) Let Rec . let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Match Verbatim With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 562.
##
## let_expr(base_cond) -> seq(Attr) Let let_binding . In base_cond [ VBAR ]
## let_in_sequence -> seq(Attr) Let let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
## In state 338, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Match Verbatim With WILD ARROW Let With
##
## Ends in an error in state: 509.
##
## let_expr(base_cond) -> seq(Attr) Let . let_binding In base_cond [ VBAR ]
## let_expr(base_cond) -> seq(Attr) Let . Rec let_binding In base_cond [ VBAR ]
## let_in_sequence -> seq(Attr) Let . let_binding In series [ End ]
## let_in_sequence -> seq(Attr) Let . Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Match Verbatim With WILD ARROW With
##
## Ends in an error in state: 508.
##
## let_expr(base_cond) -> seq(Attr) . Let let_binding In base_cond [ VBAR ]
## let_expr(base_cond) -> seq(Attr) . Let Rec let_binding In base_cond [ VBAR ]
## let_in_sequence -> seq(Attr) . Let let_binding In series [ End ]
## let_in_sequence -> seq(Attr) . Let Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 357, spurious reduction of production seq(Attr) -> 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Match Verbatim With WILD CONS Bytes With
##
## Ends in an error in state: 356.
##
## case_clause(base_cond) -> pattern . ARROW base_cond [ VBAR ]
## case_clause(last_expr) -> pattern . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 120, spurious reduction of production tail -> sub_pattern 
## In state 350, spurious reduction of production pattern -> sub_pattern CONS tail 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Match Verbatim With With
##
## Ends in an error in state: 344.
##
## match_expr(last_expr) -> Match expr With . option(VBAR) cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match expr With
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Verbatim With
##
## Ends in an error in state: 544.
##
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ SEMI Or End BOOL_OR ]
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level . Or conj_expr_level [ SEMI Or End BOOL_OR ]
## seq_expr -> disj_expr_level . [ SEMI End ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin With
##
## Ends in an error in state: 548.
##
## let_in_sequence -> seq(Attr) . Let let_binding In series [ End ]
## let_in_sequence -> seq(Attr) . Let Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 223, spurious reduction of production seq(Attr) -> 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: C_Some With
##
## Ends in an error in state: 225.
##
## constr_expr -> C_Some . argument [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## C_Some
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Constr DOT Constr With
##
## Ends in an error in state: 216.
##
## module_access_e -> Constr . DOT module_var_e [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr C_None CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Constr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Constr DOT With
##
## Ends in an error in state: 213.
##
## module_access_e -> Constr DOT . module_var_e [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr C_None CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Constr DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LBRACE Ident EQ Bytes SEMI Ident EQ Bytes SEMI With
##
## Ends in an error in state: 151.
##
## nsepseq(field_pattern,SEMI) -> field_pattern SEMI . nsepseq(field_pattern,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern,SEMI)) -> field_pattern SEMI . seq(__anonymous_0(field_pattern,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LBRACE Ident EQ Bytes SEMI Ident EQ Bytes With
##
## Ends in an error in state: 150.
##
## nsepseq(field_pattern,SEMI) -> field_pattern . [ RBRACE ]
## nsepseq(field_pattern,SEMI) -> field_pattern . SEMI nsepseq(field_pattern,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern,SEMI)) -> field_pattern . SEMI seq(__anonymous_0(field_pattern,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LBRACE Ident EQ Bytes SEMI With
##
## Ends in an error in state: 147.
##
## nsepseq(field_pattern,SEMI) -> field_pattern SEMI . nsepseq(field_pattern,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern,SEMI)) -> field_pattern SEMI . seq(__anonymous_0(field_pattern,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LBRACE Ident EQ Bytes With
##
## Ends in an error in state: 146.
##
## nsepseq(field_pattern,SEMI) -> field_pattern . [ RBRACE ]
## nsepseq(field_pattern,SEMI) -> field_pattern . SEMI nsepseq(field_pattern,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern,SEMI)) -> field_pattern . SEMI seq(__anonymous_0(field_pattern,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LBRACE Ident EQ With
##
## Ends in an error in state: 92.
##
## field_pattern -> Ident EQ . sub_pattern [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LBRACE Ident With
##
## Ends in an error in state: 91.
##
## field_pattern -> Ident . EQ sub_pattern [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LBRACE With
##
## Ends in an error in state: 90.
##
## record_pattern -> LBRACE . sep_or_term_list(field_pattern,SEMI) RBRACE [ WILD SEMI RPAR RBRACKET RBRACE LPAR LBRACE Ident EQ Constr CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LPAR Constr C_Some With
##
## Ends in an error in state: 104.
##
## constr_pattern -> C_Some . sub_pattern [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## C_Some
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LPAR Constr LBRACKET WILD SEMI WILD SEMI With
##
## Ends in an error in state: 119.
##
## nsepseq(tail,SEMI) -> tail SEMI . nsepseq(tail,SEMI) [ RBRACKET ]
## seq(__anonymous_0(tail,SEMI)) -> tail SEMI . seq(__anonymous_0(tail,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## tail SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LPAR Constr LBRACKET WILD SEMI WILD With
##
## Ends in an error in state: 118.
##
## nsepseq(tail,SEMI) -> tail . [ RBRACKET ]
## nsepseq(tail,SEMI) -> tail . SEMI nsepseq(tail,SEMI) [ RBRACKET ]
## seq(__anonymous_0(tail,SEMI)) -> tail . SEMI seq(__anonymous_0(tail,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## tail
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 120, spurious reduction of production tail -> sub_pattern 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LPAR Constr LBRACKET WILD SEMI With
##
## Ends in an error in state: 117.
##
## nsepseq(tail,SEMI) -> tail SEMI . nsepseq(tail,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(tail,SEMI)) -> tail SEMI . seq(__anonymous_0(tail,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## tail SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LPAR Constr LBRACKET WILD With
##
## Ends in an error in state: 116.
##
## nsepseq(tail,SEMI) -> tail . [ RBRACKET ]
## nsepseq(tail,SEMI) -> tail . SEMI nsepseq(tail,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(tail,SEMI)) -> tail . SEMI seq(__anonymous_0(tail,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## tail
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 120, spurious reduction of production tail -> sub_pattern 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LPAR Constr LBRACKET With
##
## Ends in an error in state: 99.
##
## list__(tail) -> LBRACKET . option(sep_or_term_list(tail,SEMI)) RBRACKET [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LPAR Constr LPAR WILD COMMA WILD COMMA With
##
## Ends in an error in state: 136.
##
## nsepseq(tail,COMMA) -> tail COMMA . nsepseq(tail,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## tail COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LPAR Constr LPAR WILD COMMA WILD With
##
## Ends in an error in state: 135.
##
## nsepseq(tail,COMMA) -> tail . [ RPAR ]
## nsepseq(tail,COMMA) -> tail . COMMA nsepseq(tail,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## tail
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 120, spurious reduction of production tail -> sub_pattern 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LPAR Constr LPAR WILD COMMA With
##
## Ends in an error in state: 134.
##
## tuple(tail) -> tail COMMA . nsepseq(tail,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## tail COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LPAR Constr LPAR WILD CONS With
##
## Ends in an error in state: 121.
##
## tail -> sub_pattern CONS . tail [ SEMI RPAR RBRACKET COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## sub_pattern CONS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LPAR Constr LPAR WILD With
##
## Ends in an error in state: 132.
##
## par(tail) -> LPAR tail . RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
## tuple(tail) -> tail . COMMA nsepseq(tail,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR tail
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 120, spurious reduction of production tail -> sub_pattern 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LPAR Constr LPAR With
##
## Ends in an error in state: 98.
##
## par(ptuple) -> LPAR . ptuple RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
## par(tail) -> LPAR . tail RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
## unit -> LPAR . RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LPAR Constr WILD With
##
## Ends in an error in state: 171.
##
## par(closed_irrefutable) -> LPAR closed_irrefutable . RPAR [ WILD RPAR LPAR LBRACE Ident EQ Constr COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR closed_irrefutable
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LPAR WILD With
##
## Ends in an error in state: 168.
##
## closed_irrefutable -> irrefutable . [ RPAR ]
## typed_pattern -> irrefutable . COLON type_expr [ RPAR ]
##
## The known suffix of the stack is as follows:
## irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 159, spurious reduction of production irrefutable -> sub_irrefutable 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LPAR With
##
## Ends in an error in state: 88.
##
## par(closed_irrefutable) -> LPAR . closed_irrefutable RPAR [ WILD RPAR LPAR LBRACE Ident EQ Constr COMMA COLON ARROW ]
## unit -> LPAR . RPAR [ WILD RPAR LPAR LBRACE Ident EQ Constr COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun WILD COMMA WILD COMMA With
##
## Ends in an error in state: 163.
##
## nsepseq(sub_irrefutable,COMMA) -> sub_irrefutable COMMA . nsepseq(sub_irrefutable,COMMA) [ WILD RPAR LPAR LBRACE Ident EQ Constr COLON ARROW ]
##
## The known suffix of the stack is as follows:
## sub_irrefutable COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun WILD COMMA With
##
## Ends in an error in state: 160.
##
## tuple(sub_irrefutable) -> sub_irrefutable COMMA . nsepseq(sub_irrefutable,COMMA) [ WILD RPAR LPAR LBRACE Ident EQ Constr COLON ARROW ]
##
## The known suffix of the stack is as follows:
## sub_irrefutable COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun WILD WILD With
##
## Ends in an error in state: 424.
##
## seq(irrefutable) -> irrefutable . seq(irrefutable) [ ARROW ]
##
## The known suffix of the stack is as follows:
## irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 159, spurious reduction of production irrefutable -> sub_irrefutable 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun WILD With
##
## Ends in an error in state: 422.
##
## nseq(irrefutable) -> irrefutable . seq(irrefutable) [ ARROW ]
##
## The known suffix of the stack is as follows:
## irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 159, spurious reduction of production irrefutable -> sub_irrefutable 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun With
##
## Ends in an error in state: 208.
##
## fun_expr(expr) -> Fun . nseq(irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Ident DOT Int DOT With
##
## Ends in an error in state: 205.
##
## nsepseq(selection,DOT) -> selection DOT . nsepseq(selection,DOT) [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr C_None CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## selection DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Ident DOT With
##
## Ends in an error in state: 201.
##
## projection -> Ident DOT . nsepseq(selection,DOT) [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr C_None CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Ident DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Fun With
##
## Ends in an error in state: 585.
##
## fun_expr(closed_if) -> Fun . nseq(irrefutable) ARROW closed_if [ Else ]
## fun_expr(expr) -> Fun . nseq(irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then If Verbatim With
##
## Ends in an error in state: 583.
##
## if_then(expr) -> If expr . Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## if_then_else(closed_if) -> If expr . Then closed_if Else closed_if [ Else ]
## if_then_else(expr) -> If expr . Then closed_if Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 594.
##
## let_expr(closed_if) -> seq(Attr) Let Rec let_binding . In closed_if [ Else ]
## let_expr(expr) -> seq(Attr) Let Rec let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
## In state 338, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Let Rec With
##
## Ends in an error in state: 593.
##
## let_expr(closed_if) -> seq(Attr) Let Rec . let_binding In closed_if [ Else ]
## let_expr(expr) -> seq(Attr) Let Rec . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Let WILD EQ Bytes With
##
## Ends in an error in state: 601.
##
## let_expr(closed_if) -> seq(Attr) Let let_binding . In closed_if [ Else ]
## let_expr(expr) -> seq(Attr) Let let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
## In state 338, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Let With
##
## Ends in an error in state: 592.
##
## let_expr(closed_if) -> seq(Attr) Let . let_binding In closed_if [ Else ]
## let_expr(closed_if) -> seq(Attr) Let . Rec let_binding In closed_if [ Else ]
## let_expr(expr) -> seq(Attr) Let . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## let_expr(expr) -> seq(Attr) Let . Rec let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Match Verbatim WILD
##
## Ends in an error in state: 578.
##
## match_expr(base_cond) -> Match expr . With option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## match_expr(base_if_then_else) -> Match expr . With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Match Verbatim With VBAR Begin
##
## Ends in an error in state: 580.
##
## match_expr(base_cond) -> Match expr With option(VBAR) . cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## match_expr(base_if_then_else) -> Match expr With option(VBAR) . cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Bytes VBAR With
##
## Ends in an error in state: 471.
##
## cases(base_cond) -> cases(base_cond) VBAR . case_clause(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## cases(base_if_then_else) -> cases(base_cond) VBAR . case_clause(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Fun With
##
## Ends in an error in state: 433.
##
## fun_expr(base_cond) -> Fun . nseq(irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## fun_expr(base_if_then_else) -> Fun . nseq(irrefutable) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW If Verbatim With
##
## Ends in an error in state: 368.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## if_then_else(base_if_then_else) -> If expr . Then closed_if Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 442.
##
## let_expr(base_cond) -> seq(Attr) Let Rec let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## let_expr(base_if_then_else) -> seq(Attr) Let Rec let_binding . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
## In state 338, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let Rec With
##
## Ends in an error in state: 441.
##
## let_expr(base_cond) -> seq(Attr) Let Rec . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## let_expr(base_if_then_else) -> seq(Attr) Let Rec . let_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 460.
##
## let_expr(base_cond) -> seq(Attr) Let let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## let_expr(base_if_then_else) -> seq(Attr) Let let_binding . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
## In state 338, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let With
##
## Ends in an error in state: 440.
##
## let_expr(base_cond) -> seq(Attr) Let . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## let_expr(base_cond) -> seq(Attr) Let . Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## let_expr(base_if_then_else) -> seq(Attr) Let . let_binding In base_if_then_else [ Else ]
## let_expr(base_if_then_else) -> seq(Attr) Let . Rec let_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Module Constr EQ Constr With
##
## Ends in an error in state: 446.
##
## local_module_alias(base_cond) -> module_alias . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## local_module_alias(base_if_then_else) -> module_alias . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 682, spurious reduction of production nsepseq(module_name,DOT) -> Constr 
## In state 685, spurious reduction of production module_alias -> Module Constr EQ nsepseq(module_name,DOT) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Module Constr EQ Struct Module Constr EQ Constr End With
##
## Ends in an error in state: 444.
##
## local_module_decl(base_cond) -> module_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## local_module_decl(base_if_then_else) -> module_decl . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Type Ident EQ Constr With
##
## Ends in an error in state: 436.
##
## local_type_decl(base_cond) -> type_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## local_type_decl(base_if_then_else) -> type_decl . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 9, spurious reduction of production variant -> Constr 
## In state 36, spurious reduction of production nsepseq(variant,VBAR) -> variant 
## In state 61, spurious reduction of production sum_type -> nsepseq(variant,VBAR) 
## In state 51, spurious reduction of production type_expr -> sum_type 
## In state 78, spurious reduction of production type_decl -> Type Ident EQ type_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW With
##
## Ends in an error in state: 439.
##
## let_expr(base_cond) -> seq(Attr) . Let let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## let_expr(base_cond) -> seq(Attr) . Let Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## let_expr(base_if_then_else) -> seq(Attr) . Let let_binding In base_if_then_else [ Else ]
## let_expr(base_if_then_else) -> seq(Attr) . Let Rec let_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 366, spurious reduction of production seq(Attr) -> 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Match Verbatim With WILD CONS Bytes With
##
## Ends in an error in state: 365.
##
## case_clause(base_cond) -> pattern . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## case_clause(base_if_then_else) -> pattern . ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 120, spurious reduction of production tail -> sub_pattern 
## In state 350, spurious reduction of production pattern -> sub_pattern CONS tail 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Match Verbatim With With
##
## Ends in an error in state: 579.
##
## match_expr(base_cond) -> Match expr With . option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## match_expr(base_if_then_else) -> Match expr With . option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Module Constr EQ Constr With
##
## Ends in an error in state: 598.
##
## local_module_alias(closed_if) -> module_alias . In closed_if [ Else ]
## local_module_alias(expr) -> module_alias . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 682, spurious reduction of production nsepseq(module_name,DOT) -> Constr 
## In state 685, spurious reduction of production module_alias -> Module Constr EQ nsepseq(module_name,DOT) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Module Constr EQ Struct Module Constr EQ Constr End With
##
## Ends in an error in state: 596.
##
## local_module_decl(closed_if) -> module_decl . In closed_if [ Else ]
## local_module_decl(expr) -> module_decl . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then Type Ident EQ Constr With
##
## Ends in an error in state: 588.
##
## local_type_decl(closed_if) -> type_decl . In closed_if [ Else ]
## local_type_decl(expr) -> type_decl . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 9, spurious reduction of production variant -> Constr 
## In state 36, spurious reduction of production nsepseq(variant,VBAR) -> variant 
## In state 61, spurious reduction of production sum_type -> nsepseq(variant,VBAR) 
## In state 51, spurious reduction of production type_expr -> sum_type 
## In state 78, spurious reduction of production type_decl -> Type Ident EQ type_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim Then With
##
## Ends in an error in state: 591.
##
## let_expr(closed_if) -> seq(Attr) . Let let_binding In closed_if [ Else ]
## let_expr(closed_if) -> seq(Attr) . Let Rec let_binding In closed_if [ Else ]
## let_expr(expr) -> seq(Attr) . Let let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## let_expr(expr) -> seq(Attr) . Let Rec let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 576, spurious reduction of production seq(Attr) -> 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Verbatim With
##
## Ends in an error in state: 575.
##
## if_then(expr) -> If expr . Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## if_then_else(expr) -> If expr . Then closed_if Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident DOT Ident WILD
##
## Ends in an error in state: 613.
##
## update_record -> LBRACE path . With sep_or_term_list(field_path_assignment,SEMI) RBRACE [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr C_None CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE path
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production nsepseq(selection,DOT) -> selection 
## In state 207, spurious reduction of production projection -> Ident DOT nsepseq(selection,DOT) 
## In state 612, spurious reduction of production path -> projection 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident EQ Bytes SEMI With
##
## Ends in an error in state: 638.
##
## nsepseq(field_assignment,SEMI) -> field_assignment SEMI . nsepseq(field_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_assignment,SEMI)) -> field_assignment SEMI . seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident EQ Bytes With
##
## Ends in an error in state: 637.
##
## nsepseq(field_assignment,SEMI) -> field_assignment . [ RBRACE ]
## nsepseq(field_assignment,SEMI) -> field_assignment . SEMI nsepseq(field_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_assignment,SEMI)) -> field_assignment . SEMI seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
## In state 609, spurious reduction of production field_assignment -> Ident EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident With
##
## Ends in an error in state: 634.
##
## field_assignment -> Ident . EQ expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident EQ Bytes SEMI With
##
## Ends in an error in state: 633.
##
## nsepseq(field_assignment,SEMI) -> field_assignment SEMI . nsepseq(field_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_assignment,SEMI)) -> field_assignment SEMI . seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident EQ Bytes With
##
## Ends in an error in state: 632.
##
## nsepseq(field_assignment,SEMI) -> field_assignment . [ RBRACE ]
## nsepseq(field_assignment,SEMI) -> field_assignment . SEMI nsepseq(field_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_assignment,SEMI)) -> field_assignment . SEMI seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
## In state 609, spurious reduction of production field_assignment -> Ident EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident WILD
##
## Ends in an error in state: 196.
##
## field_assignment -> Ident . EQ expr [ SEMI RBRACE ]
## path -> Ident . [ With ]
## projection -> Ident . DOT nsepseq(selection,DOT) [ With ]
##
## The known suffix of the stack is as follows:
## Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident With Ident DOT Ident With
##
## Ends in an error in state: 618.
##
## field_path_assignment -> path . EQ expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## path
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production nsepseq(selection,DOT) -> selection 
## In state 207, spurious reduction of production projection -> Ident DOT nsepseq(selection,DOT) 
## In state 612, spurious reduction of production path -> projection 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI Ident EQ Bytes SEMI With
##
## Ends in an error in state: 628.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment SEMI . nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment SEMI . seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI Ident EQ Bytes With
##
## Ends in an error in state: 627.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . [ RBRACE ]
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . SEMI nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment . SEMI seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
## In state 620, spurious reduction of production field_path_assignment -> path EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI With
##
## Ends in an error in state: 624.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment SEMI . nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment SEMI . seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident With Ident EQ Bytes With
##
## Ends in an error in state: 623.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . [ RBRACE ]
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . SEMI nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment . SEMI seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
## In state 620, spurious reduction of production field_path_assignment -> path EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident With Ident With
##
## Ends in an error in state: 615.
##
## path -> Ident . [ EQ ]
## projection -> Ident . DOT nsepseq(selection,DOT) [ EQ ]
##
## The known suffix of the stack is as follows:
## Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident With With
##
## Ends in an error in state: 614.
##
## update_record -> LBRACE path With . sep_or_term_list(field_path_assignment,SEMI) RBRACE [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr C_None CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE path With
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE With
##
## Ends in an error in state: 195.
##
## record_expr -> LBRACE . sep_or_term_list(field_assignment,SEMI) RBRACE [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr C_None CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
## update_record -> LBRACE . path With sep_or_term_list(field_path_assignment,SEMI) RBRACE [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr C_None CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACKET Verbatim SEMI Verbatim With
##
## Ends in an error in state: 649.
##
## nsepseq(expr,SEMI) -> expr . [ RBRACKET ]
## nsepseq(expr,SEMI) -> expr . SEMI nsepseq(expr,SEMI) [ RBRACKET ]
## seq(__anonymous_0(expr,SEMI)) -> expr . SEMI seq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACKET Verbatim With
##
## Ends in an error in state: 645.
##
## nsepseq(expr,SEMI) -> expr . [ RBRACKET ]
## nsepseq(expr,SEMI) -> expr . SEMI nsepseq(expr,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(expr,SEMI)) -> expr . SEMI seq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LPAR Verbatim COLON Constr With
##
## Ends in an error in state: 656.
##
## par(annot_expr) -> LPAR annot_expr . RPAR [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr C_None CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR annot_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 9, spurious reduction of production variant -> Constr 
## In state 36, spurious reduction of production nsepseq(variant,VBAR) -> variant 
## In state 61, spurious reduction of production sum_type -> nsepseq(variant,VBAR) 
## In state 51, spurious reduction of production type_expr -> sum_type 
## In state 655, spurious reduction of production annot_expr -> expr COLON type_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LPAR Verbatim With
##
## Ends in an error in state: 652.
##
## annot_expr -> expr . COLON type_expr [ RPAR ]
## par(expr) -> LPAR expr . RPAR [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr C_None CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Lang Verbatim With
##
## Ends in an error in state: 666.
##
## code_inj -> Lang expr . RBRACKET [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Constr C_None CONS COMMA COLON CAT Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Lang expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 247.
##
## let_expr(expr) -> seq(Attr) Let Rec let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
## In state 338, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Let Rec With
##
## Ends in an error in state: 246.
##
## let_expr(expr) -> seq(Attr) Let Rec . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Let WILD EQ Bytes With
##
## Ends in an error in state: 339.
##
## let_expr(expr) -> seq(Attr) Let let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
## In state 338, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Let With
##
## Ends in an error in state: 245.
##
## let_expr(expr) -> seq(Attr) Let . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## let_expr(expr) -> seq(Attr) Let . Rec let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: MINUS With
##
## Ends in an error in state: 192.
##
## unary_expr_level -> MINUS . call_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## MINUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim WILD
##
## Ends in an error in state: 659.
##
## match_expr(base_cond) -> Match expr . With option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With LPAR Bytes RPAR With
##
## Ends in an error in state: 348.
##
## pattern -> sub_pattern . CONS tail [ ARROW ]
## tuple(sub_pattern) -> sub_pattern . COMMA nsepseq(sub_pattern,COMMA) [ ARROW ]
##
## The known suffix of the stack is as follows:
## sub_pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With VBAR Begin
##
## Ends in an error in state: 661.
##
## match_expr(base_cond) -> Match expr With option(VBAR) . cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW Bytes VBAR With
##
## Ends in an error in state: 665.
##
## cases(base_cond) -> cases(base_cond) VBAR . case_clause(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW Fun With
##
## Ends in an error in state: 478.
##
## fun_expr(base_cond) -> Fun . nseq(irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Fun With
##
## Ends in an error in state: 373.
##
## fun_expr(base_cond) -> Fun . nseq(irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## fun_expr(closed_if) -> Fun . nseq(irrefutable) ARROW closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then If Verbatim With
##
## Ends in an error in state: 371.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## if_then_else(closed_if) -> If expr . Then closed_if Else closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 382.
##
## let_expr(base_cond) -> seq(Attr) Let Rec let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## let_expr(closed_if) -> seq(Attr) Let Rec let_binding . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
## In state 338, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let Rec With
##
## Ends in an error in state: 381.
##
## let_expr(base_cond) -> seq(Attr) Let Rec . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## let_expr(closed_if) -> seq(Attr) Let Rec . let_binding In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let WILD EQ Bytes With
##
## Ends in an error in state: 414.
##
## let_expr(base_cond) -> seq(Attr) Let let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## let_expr(closed_if) -> seq(Attr) Let let_binding . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
## In state 338, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let With
##
## Ends in an error in state: 380.
##
## let_expr(base_cond) -> seq(Attr) Let . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## let_expr(base_cond) -> seq(Attr) Let . Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## let_expr(closed_if) -> seq(Attr) Let . let_binding In closed_if [ Else ]
## let_expr(closed_if) -> seq(Attr) Let . Rec let_binding In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Module Constr EQ Constr With
##
## Ends in an error in state: 386.
##
## local_module_alias(base_cond) -> module_alias . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## local_module_alias(closed_if) -> module_alias . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 682, spurious reduction of production nsepseq(module_name,DOT) -> Constr 
## In state 685, spurious reduction of production module_alias -> Module Constr EQ nsepseq(module_name,DOT) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Module Constr EQ Struct Module Constr EQ Constr End With
##
## Ends in an error in state: 384.
##
## local_module_decl(base_cond) -> module_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## local_module_decl(closed_if) -> module_decl . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Type Ident EQ Constr With
##
## Ends in an error in state: 376.
##
## local_type_decl(base_cond) -> type_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## local_type_decl(closed_if) -> type_decl . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 9, spurious reduction of production variant -> Constr 
## In state 36, spurious reduction of production nsepseq(variant,VBAR) -> variant 
## In state 61, spurious reduction of production sum_type -> nsepseq(variant,VBAR) 
## In state 51, spurious reduction of production type_expr -> sum_type 
## In state 78, spurious reduction of production type_decl -> Type Ident EQ type_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then With
##
## Ends in an error in state: 379.
##
## let_expr(base_cond) -> seq(Attr) . Let let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## let_expr(base_cond) -> seq(Attr) . Let Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## let_expr(closed_if) -> seq(Attr) . Let let_binding In closed_if [ Else ]
## let_expr(closed_if) -> seq(Attr) . Let Rec let_binding In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 483, spurious reduction of production seq(Attr) -> 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW If Verbatim With
##
## Ends in an error in state: 482.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 492.
##
## let_expr(base_cond) -> seq(Attr) Let Rec let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
## In state 338, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW Let Rec With
##
## Ends in an error in state: 491.
##
## let_expr(base_cond) -> seq(Attr) Let Rec . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 499.
##
## let_expr(base_cond) -> seq(Attr) Let let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
## In state 338, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW Let With
##
## Ends in an error in state: 490.
##
## let_expr(base_cond) -> seq(Attr) Let . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## let_expr(base_cond) -> seq(Attr) Let . Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW Module Constr EQ Constr With
##
## Ends in an error in state: 496.
##
## local_module_alias(base_cond) -> module_alias . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 682, spurious reduction of production nsepseq(module_name,DOT) -> Constr 
## In state 685, spurious reduction of production module_alias -> Module Constr EQ nsepseq(module_name,DOT) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW Module Constr EQ Struct Module Constr EQ Constr End With
##
## Ends in an error in state: 494.
##
## local_module_decl(base_cond) -> module_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW Type Ident EQ Constr With
##
## Ends in an error in state: 486.
##
## local_type_decl(base_cond) -> type_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 9, spurious reduction of production variant -> Constr 
## In state 36, spurious reduction of production nsepseq(variant,VBAR) -> variant 
## In state 61, spurious reduction of production sum_type -> nsepseq(variant,VBAR) 
## In state 51, spurious reduction of production type_expr -> sum_type 
## In state 78, spurious reduction of production type_decl -> Type Ident EQ type_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD ARROW With
##
## Ends in an error in state: 489.
##
## let_expr(base_cond) -> seq(Attr) . Let let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## let_expr(base_cond) -> seq(Attr) . Let Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 663, spurious reduction of production seq(Attr) -> 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD COMMA WILD COMMA With
##
## Ends in an error in state: 353.
##
## nsepseq(sub_pattern,COMMA) -> sub_pattern COMMA . nsepseq(sub_pattern,COMMA) [ ARROW ]
##
## The known suffix of the stack is as follows:
## sub_pattern COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD COMMA WILD With
##
## Ends in an error in state: 352.
##
## nsepseq(sub_pattern,COMMA) -> sub_pattern . [ ARROW ]
## nsepseq(sub_pattern,COMMA) -> sub_pattern . COMMA nsepseq(sub_pattern,COMMA) [ ARROW ]
##
## The known suffix of the stack is as follows:
## sub_pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD COMMA With
##
## Ends in an error in state: 351.
##
## tuple(sub_pattern) -> sub_pattern COMMA . nsepseq(sub_pattern,COMMA) [ ARROW ]
##
## The known suffix of the stack is as follows:
## sub_pattern COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD CONS Bytes With
##
## Ends in an error in state: 662.
##
## case_clause(base_cond) -> pattern . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 120, spurious reduction of production tail -> sub_pattern 
## In state 350, spurious reduction of production pattern -> sub_pattern CONS tail 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD CONS With
##
## Ends in an error in state: 349.
##
## pattern -> sub_pattern CONS . tail [ ARROW ]
##
## The known suffix of the stack is as follows:
## sub_pattern CONS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With WILD With
##
## Ends in an error in state: 468.
##
## pattern -> core_pattern . [ ARROW ]
## sub_pattern -> core_pattern . [ CONS COMMA ]
##
## The known suffix of the stack is as follows:
## core_pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Verbatim With With
##
## Ends in an error in state: 660.
##
## match_expr(base_cond) -> Match expr With . option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr With
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Module Constr EQ Constr With
##
## Ends in an error in state: 266.
##
## local_module_alias(expr) -> module_alias . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 682, spurious reduction of production nsepseq(module_name,DOT) -> Constr 
## In state 685, spurious reduction of production module_alias -> Module Constr EQ nsepseq(module_name,DOT) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Module Constr EQ Struct Module Constr EQ Constr End With
##
## Ends in an error in state: 264.
##
## local_module_decl(expr) -> module_decl . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Not With
##
## Ends in an error in state: 187.
##
## unary_expr_level -> Not . call_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Not
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Type Ident EQ Constr With
##
## Ends in an error in state: 240.
##
## local_type_decl(expr) -> type_decl . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 9, spurious reduction of production variant -> Constr 
## In state 36, spurious reduction of production nsepseq(variant,VBAR) -> variant 
## In state 61, spurious reduction of production sum_type -> nsepseq(variant,VBAR) 
## In state 51, spurious reduction of production type_expr -> sum_type 
## In state 78, spurious reduction of production type_decl -> Type Ident EQ type_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim BOOL_AND With
##
## Ends in an error in state: 297.
##
## bin_op(conj_expr_level,BOOL_AND,comp_expr_level) -> conj_expr_level BOOL_AND . comp_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Module Let In End Else EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## conj_expr_level BOOL_AND
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim BOOL_OR With
##
## Ends in an error in state: 328.
##
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level BOOL_OR . conj_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Module Let In End Else EOF COMMA COLON BOOL_OR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level BOOL_OR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim CAT With
##
## Ends in an error in state: 280.
##
## bin_op(cons_expr_level,CAT,cat_expr_level) -> cons_expr_level CAT . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## cons_expr_level CAT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim COMMA Verbatim COMMA With
##
## Ends in an error in state: 323.
##
## nsepseq(disj_expr_level,COMMA) -> disj_expr_level COMMA . nsepseq(disj_expr_level,COMMA) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim COMMA With
##
## Ends in an error in state: 320.
##
## tuple(disj_expr_level) -> disj_expr_level COMMA . nsepseq(disj_expr_level,COMMA) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim CONS With
##
## Ends in an error in state: 294.
##
## bin_op(add_expr_level,CONS,cons_expr_level) -> add_expr_level CONS . cons_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level CONS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim EQ With
##
## Ends in an error in state: 309.
##
## bin_op(comp_expr_level,EQ,cat_expr_level) -> comp_expr_level EQ . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim GE With
##
## Ends in an error in state: 307.
##
## bin_op(comp_expr_level,GE,cat_expr_level) -> comp_expr_level GE . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level GE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim GT With
##
## Ends in an error in state: 305.
##
## bin_op(comp_expr_level,GT,cat_expr_level) -> comp_expr_level GT . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level GT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim LE With
##
## Ends in an error in state: 303.
##
## bin_op(comp_expr_level,LE,cat_expr_level) -> comp_expr_level LE . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim LT With
##
## Ends in an error in state: 301.
##
## bin_op(comp_expr_level,LT,cat_expr_level) -> comp_expr_level LT . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim MINUS With
##
## Ends in an error in state: 292.
##
## bin_op(add_expr_level,MINUS,mult_expr_level) -> add_expr_level MINUS . mult_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE PLUS Or NE Module MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level MINUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim Mod With
##
## Ends in an error in state: 262.
##
## bin_op(mult_expr_level,Mod,unary_expr_level) -> mult_expr_level Mod . unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Mod
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim NE With
##
## Ends in an error in state: 299.
##
## bin_op(comp_expr_level,NE,cat_expr_level) -> comp_expr_level NE . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level NE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim Or With
##
## Ends in an error in state: 278.
##
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level Or . conj_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Module Let In End Else EOF COMMA COLON BOOL_OR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level Or
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim PLUS With
##
## Ends in an error in state: 290.
##
## bin_op(add_expr_level,PLUS,mult_expr_level) -> add_expr_level PLUS . mult_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE PLUS Or NE Module MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level PLUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim SLASH With
##
## Ends in an error in state: 260.
##
## bin_op(mult_expr_level,SLASH,unary_expr_level) -> mult_expr_level SLASH . unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level SLASH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim TIMES With
##
## Ends in an error in state: 250.
##
## bin_op(mult_expr_level,TIMES,unary_expr_level) -> mult_expr_level TIMES . unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Let LT LE In GT GE End Else EQ EOF CONS COMMA COLON CAT BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level TIMES
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Verbatim With
##
## Ends in an error in state: 691.
##
## interactive_expr -> expr . EOF [ # ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production call_expr_level -> core_expr 
## In state 258, spurious reduction of production unary_expr_level -> call_expr_level 
## In state 239, spurious reduction of production mult_expr_level -> unary_expr_level 
## In state 249, spurious reduction of production add_expr_level -> mult_expr_level 
## In state 289, spurious reduction of production cons_expr_level -> add_expr_level 
## In state 279, spurious reduction of production cat_expr_level -> cons_expr_level 
## In state 311, spurious reduction of production comp_expr_level -> cat_expr_level 
## In state 318, spurious reduction of production conj_expr_level -> comp_expr_level 
## In state 325, spurious reduction of production disj_expr_level -> conj_expr_level 
## In state 277, spurious reduction of production base_expr(expr) -> disj_expr_level 
## In state 331, spurious reduction of production base_cond__open(expr) -> base_expr(expr) 
## In state 332, spurious reduction of production expr -> base_cond__open(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: With
##
## Ends in an error in state: 244.
##
## let_expr(expr) -> seq(Attr) . Let let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
## let_expr(expr) -> seq(Attr) . Let Rec let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 689, spurious reduction of production seq(Attr) -> 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let Ident WILD COLON WILD With
##
## Ends in an error in state: 182.
##
## let_binding -> Ident nseq(sub_irrefutable) option(type_annotation) . EQ expr [ Type Module Let In End EOF Attr ]
##
## The known suffix of the stack is as follows:
## Ident nseq(sub_irrefutable) option(type_annotation)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 22, spurious reduction of production cartesian -> core_type 
## In state 29, spurious reduction of production fun_type -> cartesian 
## In state 62, spurious reduction of production type_expr -> fun_type 
## In state 180, spurious reduction of production type_annotation -> COLON type_expr 
## In state 181, spurious reduction of production option(type_annotation) -> type_annotation 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let Ident WILD WILD With
##
## Ends in an error in state: 175.
##
## seq(sub_irrefutable) -> sub_irrefutable . seq(sub_irrefutable) [ EQ COLON ]
##
## The known suffix of the stack is as follows:
## sub_irrefutable
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let Ident WILD With
##
## Ends in an error in state: 174.
##
## nseq(sub_irrefutable) -> sub_irrefutable . seq(sub_irrefutable) [ EQ COLON ]
##
## The known suffix of the stack is as follows:
## sub_irrefutable
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let Rec With
##
## Ends in an error in state: 87.
##
## let_declaration -> seq(Attr) Let Rec . let_binding [ Type Module Let End EOF Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let WILD COLON Constr With
##
## Ends in an error in state: 336.
##
## let_binding -> irrefutable option(type_annotation) . EQ expr [ Type Module Let In End EOF Attr ]
##
## The known suffix of the stack is as follows:
## irrefutable option(type_annotation)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 9, spurious reduction of production variant -> Constr 
## In state 36, spurious reduction of production nsepseq(variant,VBAR) -> variant 
## In state 61, spurious reduction of production sum_type -> nsepseq(variant,VBAR) 
## In state 51, spurious reduction of production type_expr -> sum_type 
## In state 180, spurious reduction of production type_annotation -> COLON type_expr 
## In state 181, spurious reduction of production option(type_annotation) -> type_annotation 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let WILD With
##
## Ends in an error in state: 335.
##
## let_binding -> irrefutable . option(type_annotation) EQ expr [ Type Module Let In End EOF Attr ]
##
## The known suffix of the stack is as follows:
## irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 159, spurious reduction of production irrefutable -> sub_irrefutable 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let With
##
## Ends in an error in state: 85.
##
## let_declaration -> seq(Attr) Let . let_binding [ Type Module Let End EOF Attr ]
## let_declaration -> seq(Attr) Let . Rec let_binding [ Type Module Let End EOF Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Module Constr EQ Constr DOT With
##
## Ends in an error in state: 683.
##
## nsepseq(module_name,DOT) -> Constr DOT . nsepseq(module_name,DOT) [ Type Module Let In End EOF Attr ]
##
## The known suffix of the stack is as follows:
## Constr DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Module Constr EQ Struct Type Ident EQ Constr EOF
##
## Ends in an error in state: 675.
##
## module_decl -> Module Constr EQ Struct module_ . End [ Type Module Let In End EOF Attr ]
##
## The known suffix of the stack is as follows:
## Module Constr EQ Struct module_
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 9, spurious reduction of production variant -> Constr 
## In state 36, spurious reduction of production nsepseq(variant,VBAR) -> variant 
## In state 61, spurious reduction of production sum_type -> nsepseq(variant,VBAR) 
## In state 51, spurious reduction of production type_expr -> sum_type 
## In state 78, spurious reduction of production type_decl -> Type Ident EQ type_expr 
## In state 83, spurious reduction of production declaration -> type_decl 
## In state 678, spurious reduction of production seq(declaration) -> 
## In state 679, spurious reduction of production nseq(declaration) -> declaration seq(declaration) 
## In state 672, spurious reduction of production module_ -> nseq(declaration) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Module Constr EQ With
##
## Ends in an error in state: 81.
##
## module_alias -> Module Constr EQ . nsepseq(module_name,DOT) [ Type Module Let In End EOF Attr ]
## module_decl -> Module Constr EQ . Struct module_ End [ Type Module Let In End EOF Attr ]
##
## The known suffix of the stack is as follows:
## Module Constr EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Module Constr With
##
## Ends in an error in state: 80.
##
## module_alias -> Module Constr . EQ nsepseq(module_name,DOT) [ Type Module Let In End EOF Attr ]
## module_decl -> Module Constr . EQ Struct module_ End [ Type Module Let In End EOF Attr ]
##
## The known suffix of the stack is as follows:
## Module Constr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Module With
##
## Ends in an error in state: 79.
##
## module_alias -> Module . Constr EQ nsepseq(module_name,DOT) [ Type Module Let In End EOF Attr ]
## module_decl -> Module . Constr EQ Struct module_ End [ Type Module Let In End EOF Attr ]
##
## The known suffix of the stack is as follows:
## Module
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ Attr Constr Of With
##
## Ends in an error in state: 43.
##
## variant -> nseq(Attr) Constr Of . fun_type [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF COMMA Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Constr Of
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ Constr DOT With
##
## Ends in an error in state: 12.
##
## module_access_t -> Constr DOT . module_var_t [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Constr DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ Constr End
##
## Ends in an error in state: 686.
##
## contract -> module_ . EOF [ # ]
##
## The known suffix of the stack is as follows:
## module_
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 9, spurious reduction of production variant -> Constr 
## In state 36, spurious reduction of production nsepseq(variant,VBAR) -> variant 
## In state 61, spurious reduction of production sum_type -> nsepseq(variant,VBAR) 
## In state 51, spurious reduction of production type_expr -> sum_type 
## In state 78, spurious reduction of production type_decl -> Type Ident EQ type_expr 
## In state 83, spurious reduction of production declaration -> type_decl 
## In state 678, spurious reduction of production seq(declaration) -> 
## In state 679, spurious reduction of production nseq(declaration) -> declaration seq(declaration) 
## In state 672, spurious reduction of production module_ -> nseq(declaration) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ Constr Of With
##
## Ends in an error in state: 10.
##
## variant -> Constr Of . fun_type [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF COMMA Attr ]
##
## The known suffix of the stack is as follows:
## Constr Of
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ Constr VBAR With
##
## Ends in an error in state: 37.
##
## nsepseq(variant,VBAR) -> variant VBAR . nsepseq(variant,VBAR) [ Type SEMI RPAR RBRACE Module Let In End EQ EOF COMMA Attr ]
##
## The known suffix of the stack is as follows:
## variant VBAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ LBRACE Ident COLON Constr SEMI Ident COLON Constr With
##
## Ends in an error in state: 71.
##
## nsepseq(field_decl,SEMI) -> field_decl . [ RBRACE ]
## nsepseq(field_decl,SEMI) -> field_decl . SEMI nsepseq(field_decl,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_decl,SEMI)) -> field_decl . SEMI seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 9, spurious reduction of production variant -> Constr 
## In state 36, spurious reduction of production nsepseq(variant,VBAR) -> variant 
## In state 61, spurious reduction of production sum_type -> nsepseq(variant,VBAR) 
## In state 51, spurious reduction of production type_expr -> sum_type 
## In state 59, spurious reduction of production field_decl -> seq(Attr) Ident COLON type_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ LBRACE Ident COLON Constr With
##
## Ends in an error in state: 67.
##
## nsepseq(field_decl,SEMI) -> field_decl . [ RBRACE ]
## nsepseq(field_decl,SEMI) -> field_decl . SEMI nsepseq(field_decl,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_decl,SEMI)) -> field_decl . SEMI seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 9, spurious reduction of production variant -> Constr 
## In state 36, spurious reduction of production nsepseq(variant,VBAR) -> variant 
## In state 61, spurious reduction of production sum_type -> nsepseq(variant,VBAR) 
## In state 51, spurious reduction of production type_expr -> sum_type 
## In state 59, spurious reduction of production field_decl -> seq(Attr) Ident COLON type_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ LBRACE Ident With
##
## Ends in an error in state: 57.
##
## field_decl -> seq(Attr) Ident . COLON type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ LBRACE With
##
## Ends in an error in state: 56.
##
## field_decl -> seq(Attr) . Ident COLON type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 55, spurious reduction of production seq(Attr) -> 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ LPAR WILD COMMA Constr RPAR With
##
## Ends in an error in state: 16.
##
## core_type -> type_tuple . Ident [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## type_tuple
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ LPAR WILD COMMA WILD With
##
## Ends in an error in state: 49.
##
## nsepseq(type_expr,COMMA) -> type_expr . [ RPAR ]
## nsepseq(type_expr,COMMA) -> type_expr . COMMA nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 22, spurious reduction of production cartesian -> core_type 
## In state 29, spurious reduction of production fun_type -> cartesian 
## In state 62, spurious reduction of production type_expr -> fun_type 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ LPAR WILD With
##
## Ends in an error in state: 46.
##
## par(type_expr) -> LPAR type_expr . RPAR [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF COMMA Attr ARROW ]
## tuple(type_expr) -> type_expr . COMMA nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 22, spurious reduction of production cartesian -> core_type 
## In state 29, spurious reduction of production fun_type -> cartesian 
## In state 62, spurious reduction of production type_expr -> fun_type 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ VBAR Attr With
##
## Ends in an error in state: 41.
##
## variant -> nseq(Attr) . Constr [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF COMMA Attr ]
## variant -> nseq(Attr) . Constr Of fun_type [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF COMMA Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 39, spurious reduction of production seq(Attr) -> 
## In state 40, spurious reduction of production nseq(Attr) -> Attr seq(Attr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ VBAR With
##
## Ends in an error in state: 53.
##
## sum_type -> seq(Attr) VBAR . nsepseq(variant,VBAR) [ Type SEMI RPAR RBRACE Module Let In End EQ EOF COMMA Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) VBAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ WILD ARROW With
##
## Ends in an error in state: 30.
##
## fun_type -> cartesian ARROW . fun_type [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF COMMA Attr ]
##
## The known suffix of the stack is as follows:
## cartesian ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ WILD TIMES Constr With
##
## Ends in an error in state: 11.
##
## module_access_t -> Constr . DOT module_var_t [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Constr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ WILD TIMES WILD TIMES With
##
## Ends in an error in state: 26.
##
## nsepseq(core_type,TIMES) -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ WILD TIMES With
##
## Ends in an error in state: 23.
##
## cartesian -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident EQ With
##
## Ends in an error in state: 52.
##
## record_type -> seq(Attr) . LBRACE sep_or_term_list(field_decl,SEMI) RBRACE [ Type SEMI RPAR RBRACE Module Let In End EQ EOF COMMA Attr ]
## sum_type -> seq(Attr) . VBAR nsepseq(variant,VBAR) [ Type SEMI RPAR RBRACE Module Let In End EQ EOF COMMA Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 3, spurious reduction of production seq(Attr) -> 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type Ident With
##
## Ends in an error in state: 2.
##
## type_decl -> Type Ident . EQ type_expr [ Type Module Let In End EOF Attr ]
##
## The known suffix of the stack is as follows:
## Type Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Type With
##
## Ends in an error in state: 1.
##
## type_decl -> Type . Ident EQ type_expr [ Type Module Let In End EOF Attr ]
##
## The known suffix of the stack is as follows:
## Type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: With
##
## Ends in an error in state: 84.
##
## let_declaration -> seq(Attr) . Let let_binding [ Type Module Let End EOF Attr ]
## let_declaration -> seq(Attr) . Let Rec let_binding [ Type Module Let End EOF Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 0, spurious reduction of production seq(Attr) -> 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

